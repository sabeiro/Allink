.TH "Vettore" 3 "Thu Mar 27 2014" "Version v0.1" "Allink" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Vettore \- 
.PP
Geometrical operations on vectors\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MatematicaVect\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVettore\fP (int N)"
.br
.RI "\fIAllocates\&. \fP"
.ti -1c
.RI "\fBVettore\fP ()"
.br
.RI "\fIAllocates\&. \fP"
.ti -1c
.RI "\fB~Vettore\fP ()"
.br
.RI "\fIFrees\&. \fP"
.ti -1c
.RI "\fBVettore\fP (double *Pos, int N)"
.br
.RI "\fIAllocates and assigns\&. \fP"
.ti -1c
.RI "\fBVettore\fP (double \fBx\fP, double y, double z)"
.br
.RI "\fIThree dim vector\&. \fP"
.ti -1c
.RI "\fBVettore\fP (double \fBx\fP, double y)"
.br
.RI "\fITwo dim vector\&. \fP"
.ti -1c
.RI "double \fBAbs\fP ()"
.br
.RI "\fIReturn the absolute value\&. \fP"
.ti -1c
.RI "double \fBNorm\fP ()"
.br
.RI "\fIReturn the norm of a \fBVettore\fP\&. \fP"
.ti -1c
.RI "double \fBNormalize\fP ()"
.br
.RI "\fINormlizes a \fBVettore\fP\&. \fP"
.ti -1c
.RI "void \fBNormal\fP (const \fBVettore\fP *u, const \fBVettore\fP *v)"
.br
.RI "\fIComputes the normal with respect to the \fBVettore\fP u and v\&. \fP"
.ti -1c
.RI "void \fBNormalSurf\fP (const \fBVettore\fP *u, const \fBVettore\fP *v, const \fBVettore\fP *w)"
.br
.RI "\fIComputes the normal to the plane described by u,v,w\&. \fP"
.ti -1c
.RI "double \fBProjOnSurf\fP (\fBVettore\fP *S1, \fBVettore\fP *S2, \fBVettore\fP *S3, \fBVettore\fP *P)"
.br
.RI "\fIProject a point P on the point PS perpendicular to the surface described by the points S1, S2 and S3\&. \fP"
.ti -1c
.RI "void \fBMult\fP (double Fact)"
.br
.RI "\fImultiply by a scalar \fP"
.ti -1c
.RI "void \fBSubs\fP (const \fBVettore\fP *u, const \fBVettore\fP *v)"
.br
.RI "\fIsubstruct two \fBVettore\fP \fP"
.ti -1c
.RI "double \fBScalS\fP (const \fBVettore\fP *u, const \fBVettore\fP *v)"
.br
.RI "\fIMultiplies the components of a \fBVettore\fP for a scalar\&. \fP"
.ti -1c
.RI "double \fBCosAngle\fP (\fBVettore\fP *u)"
.br
.RI "\fIComputes the cosine with respect to\&. \fP"
.ti -1c
.RI "double \fBCosAngle\fP (\fBVettore\fP *u, \fBVettore\fP *v)"
.br
.RI "\fIComputes the cosine between two \fBVettore\fP\&. \fP"
.ti -1c
.RI "double \fBSinAngle\fP (\fBVettore\fP *u, \fBVettore\fP *v)"
.br
.RI "\fIComputes the sine between two \fBVettore\fP\&. \fP"
.ti -1c
.RI "double \fBSinAngle\fP (\fBVettore\fP *u)"
.br
.RI "\fIComputes the sine with respect to\&. \fP"
.ti -1c
.RI "double \fBAngle\fP (\fBVettore\fP *u, \fBVettore\fP *v)"
.br
.RI "\fIComputes the angle between two Vetttore\&. \fP"
.ti -1c
.RI "double \fBAngle\fP (\fBVettore\fP *u)"
.br
.RI "\fIComputes the angle between two Vetttore\&. \fP"
.ti -1c
.RI "double \fBCol\fP (int N)"
.br
.RI "\fIValue of the N column\&. \fP"
.ti -1c
.RI "double \fBVal\fP (int N)"
.br
.RI "\fIValue of the N column\&. \fP"
.ti -1c
.RI "void \fBSet\fP (double \fBVal\fP, int \fBCol\fP)"
.br
.RI "\fISet the N column\&. \fP"
.ti -1c
.RI "void \fBAxis\fP (\fBVettore\fP *u, \fBVettore\fP *v)"
.br
.RI "\fICalculates the axis formed by two \fBVettore\fP\&. \fP"
.ti -1c
.RI "void \fBScalV\fP (const \fBVettore\fP *u, const \fBVettore\fP *v)"
.br
.RI "\fIScalar product between two \fBVettore\fP\&. \fP"
.ti -1c
.RI "double \fBVetV\fP (const \fBVettore\fP *u, const \fBVettore\fP *v)"
.br
.RI "\fIVectorial product between two \fBVettore\fP returns the area\&. \fP"
.ti -1c
.RI "double \fBVetV3\fP (const \fBVettore\fP *u, const \fBVettore\fP *v)"
.br
.RI "\fIVectorial product between two \fBVettore\fP in three dimension (faster) returns the area\&. \fP"
.ti -1c
.RI "double \fBVetV\fP (const \fBVettore\fP *u)"
.br
.RI "\fIVectorial product between two \fBVettore\fP returns the area\&. \fP"
.ti -1c
.RI "double \fBProjOnAxis\fP (\fBVettore\fP *a)"
.br
.RI "\fIProjects along the axis\&. \fP"
.ti -1c
.RI "double \fBProjOnAxis\fP (\fBVettore\fP *Pos, \fBVettore\fP *\fBAxis\fP)"
.br
.RI "\fIThe length of Pos on Axis\&. \fP"
.ti -1c
.RI "void \fBApplyOn\fP (\fBVettore\fP *o)"
.br
.RI "\fIApply on a origin\&. \fP"
.ti -1c
.RI "void \fBCopy\fP (\fBVettore\fP *o)"
.br
.RI "\fICopy the vector\&. \fP"
.ti -1c
.RI "void \fBExport\fP (double *\fBx\fP)"
.br
.RI "\fIExport\&. \fP"
.ti -1c
.RI "void \fBPerpTo\fP (\fBVettore\fP *o)"
.br
.RI "\fIThe vector perpendicolar\&. \fP"
.ti -1c
.RI "double \fBPerpTo\fP (\fBVettore\fP *Pos, \fBVettore\fP *\fBAxis\fP)"
.br
.RI "\fIThe vector perpendicolar\&. \fP"
.ti -1c
.RI "double \fBPerpTo3\fP (\fBVettore\fP *Pos, \fBVettore\fP *\fBAxis\fP)"
.br
.RI "\fIThe vector perpendicolar in three dimension (faster) \fP"
.ti -1c
.RI "void \fBPrint\fP ()"
.br
.RI "\fIPrints the components\&. \fP"
.ti -1c
.RI "void \fBRescale\fP (double NewLength)"
.br
.RI "\fIRescale the total length of the vector\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator+\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fISum component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator+\fP (const \fBVettore\fP &Vet) const "
.br
.RI "\fISum component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP & \fBoperator+=\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fISum component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator-\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fIDifference component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator-\fP (const \fBVettore\fP &Vet) const "
.br
.RI "\fIDifference component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP & \fBoperator-=\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fIDifference component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator*\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fIMoltiplication component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP & \fBoperator*=\fP (const \fBVettore\fP &vec)"
.br
.RI "\fIScalar product\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator*\fP (const double Fact)"
.br
.RI "\fIMoltiplication component by a scalar\&. \fP"
.ti -1c
.RI "\fBVettore\fP & \fBoperator*=\fP (const double f)"
.br
.RI "\fIMoltiplication component by a scalar\&. \fP"
.ti -1c
.RI "double \fBoperator%\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fIScalar product\&. \fP"
.ti -1c
.RI "double & \fBoperator%=\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fIScalar product\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator^\fP (const \fBVettore\fP &vec)"
.br
.RI "\fIVectorial product\&. \fP"
.ti -1c
.RI "\fBVettore\fP & \fBoperator^=\fP (const \fBVettore\fP &vec)"
.br
.RI "\fIVectorial product\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator/\fP (const \fBVettore\fP &vec)"
.br
.RI "\fIDivision component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP & \fBoperator/=\fP (const \fBVettore\fP &vec)"
.br
.RI "\fIDivision component by component\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator=\fP (const \fBVettore\fP &Vet)"
.br
.RI "\fIAssigns the entries of the rhs \fBVettore\fP to the lhs\&. \fP"
.ti -1c
.RI "double * \fBgetPtr\fP ()"
.br
.RI "\fIReturns a entry\&. \fP"
.ti -1c
.RI "const double * \fBgetPtr\fP () const "
.br
.RI "\fIReturns a entry\&. \fP"
.ti -1c
.RI "double & \fBoperator[]\fP (int col)"
.br
.RI "\fIReturns a entry\&. \fP"
.ti -1c
.RI "double \fBoperator[]\fP (int col) const "
.br
.RI "\fIReturns a entry\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "int \fBNDim\fP"
.br
.RI "\fIDimension allocated\&. \fP"
.ti -1c
.RI "double * \fBx\fP"
.br
.RI "\fIWhere the data are stored\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Geometrical operations on vectors\&. 
.PP
Definition at line 9 of file MatematicaVect\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "double \fBCosAngle\fP (\fBVettore\fP *u)"
.PP
Computes the cosine with respect to\&. \fBParameters:\fP
.RS 4
\fIu\fP 
.RE
.PP

.PP
Definition at line 229 of file MatematicaVect\&.cpp\&.
.PP
References NDim, Norm(), and x\&.
.PP
Referenced by Angle(), Forces::CalcBending(), and ProjOnAxis()\&.
.SS "double \fBSinAngle\fP (\fBVettore\fP *u)"
.PP
Computes the sine with respect to\&. \fBParameters:\fP
.RS 4
\fIu\fP 
.RE
.PP

.PP
Definition at line 247 of file MatematicaVect\&.cpp\&.
.PP
References NDim, Norm(), and x\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Allink from the source code\&.
