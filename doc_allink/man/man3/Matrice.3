.TH "Matrice" 3 "Fri Aug 17 2018" "Version v0.1" "Allink" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Matrice \- \fBMatrice\fP computes the algebric operations on matrices\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MatematicaMatrix\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMatrice\fP (int newNSize)"
.br
.RI "\fIcreates a square \fBMatrice\fP \fP"
.ti -1c
.RI "\fBMatrice\fP (int NRow, int NCol)"
.br
.RI "\fICreates a NRow x NCol \fBMatrice\fP\&. \fP"
.ti -1c
.RI "\fBMatrice\fP (int NRow, int NCol, int NZed)"
.br
.RI "\fICreates a NRow x NCol x NZed \fBMatrice\fP\&. \fP"
.ti -1c
.RI "\fBMatrice\fP (int ExtNRow, int ExtNCol, double *pointer)"
.br
.RI "\fICreates a NRow x NCol \fBMatrice\fP which points to an already allocated double\&. \fP"
.ti -1c
.RI "\fBMatrice\fP (\fBSPLINE\fP Wg)"
.br
.RI "\fIA 3x3 \fBMatrice\fP defined as discreate two dimensional derivation operator\&. \fP"
.ti -1c
.RI "\fBMatrice\fP (\fBSPLINE\fP Wg, int Dim)"
.br
.RI "\fIA 5x5 \fBMatrice\fP defined as discrete two dimensional derivation operator, Dim defines different options\&. \fP"
.ti -1c
.RI "\fBMatrice\fP (\fBQuadri\fP q, int dim)"
.br
.RI "\fIa 4x4 or 3x3 \fBMatrice\fP defined by a quaternion \fP"
.ti -1c
.RI "\fBMatrice\fP (double *M, int Nr, int Nc)"
.br
.RI "\fIThe data array point to an alreay allocated array\&. \fP"
.ti -1c
.RI "\fBMatrice\fP (double Roll, double Pitch, double Yaw, int NDim)"
.br
.RI "\fIDefine a rotation matrix from Euler angles\&. \fP"
.ti -1c
.RI "\fBMatrice\fP (double *Axis, double Angle, int NDim)"
.br
.RI "\fIDefine a rotation matrix from a axis and a rotation angle\&. \fP"
.ti -1c
.RI "\fB~Matrice\fP ()"
.br
.RI "\fIFreeing\&. \fP"
.ti -1c
.RI "bool \fBSet\fP (int row, int column, double \fBVal\fP)"
.br
.RI "\fISet a coefficient\&. \fP"
.ti -1c
.RI "bool \fBAdd\fP (int row, int col, double \fBVal\fP)"
.br
.RI "\fIAdd the value of the coefficient to the previous one\&. \fP"
.ti -1c
.RI "int \fBSize\fP ()"
.br
.RI "\fISize of \fBMatrice\fP\&. \fP"
.ti -1c
.RI "int \fBpNCol\fP ()"
.br
.RI "\fINumber of columns\&. \fP"
.ti -1c
.RI "int \fBpNRow\fP ()"
.br
.RI "\fINumber of rows\&. \fP"
.ti -1c
.RI "int \fBpNZed\fP ()"
.br
.RI "\fINumber of zed\&. \fP"
.ti -1c
.RI "void \fBApply\fP (double *Known, double *UnKnown)"
.br
.RI "\fIApply Ax = y\&. \fP"
.ti -1c
.RI "int \fBSolve\fP (double *Known, double *UnKnown)"
.br
.RI "\fISolve a system A|b = y\&. \fP"
.ti -1c
.RI "int \fBgetNRow\fP ()"
.br
.RI "\fIReturn size\&. \fP"
.ti -1c
.RI "void \fBShout\fP (const char *s,\&.\&.\&.)"
.br
.RI "\fIName of the last function called\&. For debugging\&. \fP"
.ti -1c
.RI "void \fBcomparetoidentity\fP ()"
.br
.RI "\fICompare to identity\&. \fP"
.ti -1c
.RI "void \fBsettoproduct\fP (\fBMatrice\fP &left, \fBMatrice\fP &right)"
.br
.RI "\fISet to product\&. \fP"
.ti -1c
.RI "void \fBcopymatrix\fP (\fBMatrice\fP &source)"
.br
.RI "\fICopy matrix\&. \fP"
.ti -1c
.RI "void \fBsetNRow\fP (int newNRow)"
.br
.RI "\fISet new size\&. \fP"
.ti -1c
.RI "void \fBgetvalue\fP (int row, int column, double &returnvalue, bool &success)"
.br
.RI "\fIReturn value\&. \fP"
.ti -1c
.RI "void \fBInvert\fP ()"
.br
.RI "\fIInvert\&. \fP"
.ti -1c
.RI "void \fBMult\fP (\fBMatrice\fP &A, \fBMatrice\fP &B)"
.br
.RI "\fIMultiplication between two matrices\&. \fP"
.ti -1c
.RI "void \fBMult\fP (\fBMatrice\fP &A)"
.br
.RI "\fIMultiplication by matrices\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBMult\fP (\fBMatrice\fP &A, \fBVettore\fP &v)"
.br
.RI "\fIMultiplication by a vector\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBMult\fP (\fBVettore\fP &v)"
.br
.RI "\fIMultiplication by a vector\&. \fP"
.ti -1c
.RI "void \fBMult\fP (\fBVettore\fP &v, \fBVettore\fP &u)"
.br
.RI "\fIMultiplication by a vector on a vector u\&. \fP"
.ti -1c
.RI "void \fBRandomFill\fP (double Max)"
.br
.RI "\fIFill the entries randomly\&. \fP"
.ti -1c
.RI "void \fBFillDiffOperator\fP (\fBSPLINE\fP Wg, int NDim)"
.br
.RI "\fIFill the entries of a differential operator\&. \fP"
.ti -1c
.RI "void \fBFillCanny\fP ()"
.br
.RI "\fIFill the entries for the Canny edge detector\&. \fP"
.ti -1c
.RI "void \fBFillGaussian\fP (double Sigma, double CutOff)"
.br
.RI "\fIFill the entries for the Gauss blur\&. \fP"
.ti -1c
.RI "void \fBFillGaussian5\fP ()"
.br
.RI "\fIFill the entries for the 5x5 Gauss blur\&. \fP"
.ti -1c
.RI "void \fBTranspose\fP ()"
.br
.RI "\fITranspose the matrix\&. \fP"
.ti -1c
.RI "void \fBNormalize\fP ()"
.br
.RI "\fINormalize the matrix\&. \fP"
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "\fISet all the entries to zero\&. \fP"
.ti -1c
.RI "void \fBMultiply\fP (double \fBVal\fP)"
.br
.RI "\fIMultiply by a scalar\&. \fP"
.ti -1c
.RI "void \fBCopyOn\fP (\fBMatrice\fP *B)"
.br
.RI "\fICopy on a matrix\&. \fP"
.ti -1c
.RI "void \fBPrint\fP ()"
.br
.RI "\fIPrint the entries\&. \fP"
.ti -1c
.RI "double \fBVal\fP (int row)"
.br
.RI "\fIReturns a value in 1d\&. \fP"
.ti -1c
.RI "double \fBVal\fP (int row, int col)"
.br
.RI "\fIReturns a value in 2d\&. \fP"
.ti -1c
.RI "double \fBVal\fP (int row, int col, int zed)"
.br
.RI "\fIReturns a value in 3d\&. \fP"
.ti -1c
.RI "double \fBDet\fP ()"
.br
.RI "\fIComputes the determinants\&. \fP"
.ti -1c
.RI "\fBMatrice\fP \fBoperator+\fP (\fBMatrice\fP &)"
.br
.RI "\fISums two matrices\&. \fP"
.ti -1c
.RI "\fBMatrice\fP \fBoperator*\fP (\fBMatrice\fP &A)"
.br
.RI "\fIMultiplies two matrices\&. \fP"
.ti -1c
.RI "\fBMatrice\fP \fBoperator*\fP (const double &) const "
.br
.RI "\fIMultiplies per a scalar\&. \fP"
.ti -1c
.RI "\fBVettore\fP \fBoperator*\fP (const \fBVettore\fP &) const "
.br
.RI "\fIMultiplies per a vector\&. \fP"
.ti -1c
.RI "\fBMatrice\fP \fBoperator=\fP (\fBMatrice\fP &)"
.br
.RI "\fICopy two matrices\&. \fP"
.ti -1c
.RI "\fBMatrice\fP \fBoperator^\fP (\fBMatrice\fP &) const "
.br
.RI "\fITensor product? \fP"
.ti -1c
.RI "void \fBConvoluteMatrix\fP (double *Plot, int NGrid, int NDim, int IfMinImConv)"
.br
.RI "\fIConvolute with a matrix\&. \fP"
.ti -1c
.RI "void \fBConvoluteMatrix1\fP (double *Plot, int NGrid)"
.br
.RI "\fIConvolute with a matrix\&. \fP"
.ti -1c
.RI "void \fBConvoluteMatrix1MinImConv\fP (double *Plot, int NGrid)"
.br
.RI "\fIConvolute with a matrix\&. \fP"
.ti -1c
.RI "void \fBConvoluteMatrix2\fP (double *Plot, int NGrid)"
.br
.RI "\fIConvolute with a matrix\&. \fP"
.ti -1c
.RI "void \fBConvoluteMatrix2MinImConv\fP (double *Plot, int NGrid)"
.br
.RI "\fIConvolute with a matrix\&. \fP"
.ti -1c
.RI "void \fBConvoluteMatrix3\fP (double *Plot, int NGrid)"
.br
.RI "\fIConvolute with a matrix\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "double * \fBdata\fP"
.br
.RI "\fIStored entries\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\fBMatrice\fP computes the algebric operations on matrices\&. 
.PP
Definition at line 10 of file MatematicaMatrix\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBMatrice\fP (\fBQuadri\fP q, int dim)"

.PP
a 4x4 or 3x3 \fBMatrice\fP defined by a quaternion 
.PP
\fBParameters:\fP
.RS 4
\fI\fBQuadri\fP\fP q 
.RE
.PP

.PP
Definition at line 154 of file MatematicaAlgebra\&.cpp\&.
.PP
References data, Quadri::w, Quadri::x, Quadri::y, and Quadri::z\&.
.SH "Member Function Documentation"
.PP 
.SS "void ConvoluteMatrix2 (double * Plot, int NGrid)"

.PP
Convolute with a matrix\&. no minimum image convention 
.PP
Definition at line 999 of file MatematicaAlgebra\&.cpp\&.
.PP
References pNCol(), pNRow(), and Val()\&.
.PP
Referenced by ConvoluteMatrix()\&.
.SS "void ConvoluteMatrix2MinImConv (double * Plot, int NGrid)"

.PP
Convolute with a matrix\&. with minimum image convention 
.PP
Definition at line 1037 of file MatematicaAlgebra\&.cpp\&.
.PP
References pNCol(), pNRow(), and Val()\&.
.PP
Referenced by ConvoluteMatrix()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Allink from the source code\&.
